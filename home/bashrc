#!/usr/bin/env bash

# ~/.bashrc


# This is a dirty hack to make it easier to reset the keyboard. Udev rules did
# not solve this problem. Something about the right session not getting the new
# keyboard changes.
#setxkbmap -option caps:escape

# This just ensures everything is there.
xrdb ~/.Xresources

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

bash_completion="/usr/share/bash-completion/bash_completion"
[[ -f "${bash_completion}" ]] && . "${bash_completion}"

# Add git completion to standard git commands and aliases.
if [ -f ~/.git-completion.bash ]; then
    . ~/.git-completion.bash

    # Add git completion to aliases
    __git_complete g  __git_main
    __git_complete gu  _git_pull
    __git_complete gp  _git_push
    __git_complete ga  _git_add
    __git_complete gd  _git_diff
    __git_complete gs  _git_stash
    __git_complete gb  _git_branch
    __git_complete gba _git_branch
    __git_complete gc  _git_commit
    __git_complete gca _git_commit
    __git_complete gco _git_checkout
    __git_complete gm  _git_merge
    __git_complete gff _git_merge
    __git_complete gl  _git_log
    __git_complete gla _git_log
    __git_complete gll _git_log
fi

function color() {
    echo "\[$(tput setaf "${1}")\]"

    if [[ "$#" -eq 2 ]]; then
        echo "\[$(tput setab "${2}")\]"
    fi
}

function reset_color() {
    echo "\[$(tput setaf 7)\]"
}

function success_prompt() {
    local last_status="${?}"
    local success="^_^"
    local failure="0_o"
    if [[ "${last_status}" != "0" ]]; then
        echo "$(color 1)${failure}$(reset_color)"
    else
        echo "$(color 2)${success}$(reset_color)"
    fi
}

function bash_prompt() {
    #local files
    #local files_prompt
    #files=$(find -maxdepth 1 | wc | awk '{print $1}')
    #files_prompt="${files} files"

    last_status=$(success_prompt)

    local login
    local time
    local directory

    login="$(color 4)\u$(reset_color)@$(color 6)\H$(reset_color)"
    time="$(color 5)\t$(reset_color)"
    directory="$(color 3)\w$(reset_color)"

    local virtualenv

    local sep="─"
    local sep="~"
    local lb="("
    local rb=")"

    if printenv VIRTUAL_ENV &>/dev/null; then
        virtualenv=$(printenv VIRTUAL_ENV | awk -F/ '{print $NF}')
        virtualenv="${sep}{${virtualenv}}"
    else
        virtualenv=""
    fi

    if git status &>/dev/null; then
        local gitbranch
        gitbranch=$(git branch | egrep "^\*" | awk '{print $NF}')

        local count_untracked="0"
        local count_staged="0"
        local count_modified="0"

        while IFS= read -r line; do
            x=$(echo "${line}" | head -c 1)
            y=$(echo "${line}" | head -c 2 | tail -c 1)

            #echo "x=$x y=$y"

            if [[ "$x" = "?" ]] && [[ "$y" = "?" ]]; then
                count_untracked=$((count_untracked + 1))
            elif [[ "$x" != " " ]] && [[ "$y" == " " ]]; then
                count_staged=$((count_staged + 1))
            elif [[ "$x" == " " ]] && [[ "$y" != " " ]]; then
                count_modified=$((count_modified + 1))
            fi
        done < <(git status -s)


        if [[ ${count_untracked} != 0 ]]; then
            count_untracked=" $(color 3)...${count_untracked}$(reset_color)"
        else
            count_untracked=""
        fi

        if [[ ${count_modified} != 0 ]]; then
            count_modified=" $(color 1)+${count_modified}$(reset_color)"
        else
            count_modified=""
        fi

        if [[ ${count_staged} != 0 ]]; then
            count_staged=" $(color 2)●${count_staged}$(reset_color)"
        else
            count_staged=""
        fi


        # M == Modified and Unstaged ●
        # D == Deleted  -
        # R == Renamed  R
        # C == Copied   C
        # U == Updated but Unmerged
        # A == Added
        # "??" == Untracked
        local gitprompt="${sep}${lb}${gitbranch}${count_staged}${count_modified}${count_untracked}${rb}"
    fi

    echo ""
    echo -n "${lb}${last_status}${rb}"
    echo -n "${sep}"
    echo -n "${lb}${time}${rb}"
    echo -n "${sep}"
    echo -n "${lb}${login}${rb}"
    echo -n "${virtualenv}"
    echo -n "${sep}"
    echo -n "${lb}${directory}${rb}"
    echo -n "${gitprompt}"
    echo ""
    echo "$ "
}

date-utc-to-au() {
    FOUNDEPOCH=$(TZ=UTC date +%s -d "$@")
    echo -en "$FOUNDEPOCH\t"
    TZ="Australia/Sydney" date -d @${FOUNDEPOCH}
}

gitcopush() {
    set -eu

    GIT_DESCRIPTION=$*
    JIRA_URL='https://extranet.atlassian.com/jira'
    TICKET_NUM="${1^^}"

    if [[ ${TICKET_NUM:0:7} != "PURSRE-" && ${TICKET_NUM:0:4} != "PUR-" && ${TICKET_NUM:0:5} != "PLSE-" ]]; then
        echo "No ticket detected. Creating new ticket"

        PROJECT_KEY="PURSRE"
        TICKET_NUM=$(curl \
            --silent \
            --data "{ \"fields\": { \"reporter\":{\"name\": \"${USER}\" }, \"assignee\":{\"name\":\"${USER}\"}, \"project\": { \"key\": \"$PROJECT_KEY\" }, \"summary\": \"$GIT_DESCRIPTION\", \"description\": \"$GIT_DESCRIPTION\", \"issuetype\": { \"name\": \"Task\" } } }" \
            --user "${USER}" \
            -X POST \
            --header "Content-Type: application/json" \
            $JIRA_URL/rest/api/2/issue/ | \
            jq '.key')
        TICKET_NUM="${TICKET_NUM//\"/}"
        GIT_DESCRIPTION="${TICKET_NUM} ${GIT_DESCRIPTION}"
    fi

    BRANCH_NAME="${GIT_DESCRIPTION//[ \.]/_}"
    git checkout -b "$BRANCH_NAME"
    git commit --patch --interactive -m "$GIT_DESCRIPTION"
    git push 2>&1 | tee "/tmp/$BRANCH_NAME"

    google-chrome $(grep -A1 "Create pull request for" "/tmp/$BRANCH_NAME" | perl -nle 'print $1 if m#(https://(stash.atlassian.com|bitbucket.org)\S+)#')
    sleep 0.5
    google-chrome "${JIRA_URL}/browse/${TICKET_NUM}"
    set +eu
}

PROMPT_COMMAND='PS1="$(bash_prompt)"'

BASE16_SHELL="$HOME/.config/base16-shell/scripts/base16-tomorrow-night.sh"
[[ -s "$BASE16_SHELL" ]] && source $BASE16_SHELL

export TERM='rxvt-256color'
export EDITOR='vim'
export HISTSIZE=5000

alias vim='vim -O'
alias ..='cd ..'
alias ...='cd ../..'
alias please='sudo'

alias c='clear'
alias cls="clear && ls -l"
alias clt="clear && tree"
alias ls='ls --color=auto'
alias l='ls -oh'
alias lt='ls -lhtc'
alias la='ls -lha'
alias ll='ls -l'
alias rm='rm -I'
alias grep='grep -i'

id_rsas=$(ls --ignore="*.pub" -w 1 ~/.ssh/ | grep "^id_" | tr '\n' ' ')
alias kchour="eval \`keychain --eval --agents ssh --timeout 60 --quiet $id_rsas\`"
alias kcday="eval \`keychain --eval --agents ssh --timeout 480 --quiet $id_rsas\`"

# Aliases for Git:
alias g='/usr/bin/git status'
alias gu='kcday && /usr/bin/git pull'
alias gp='kcday && /usr/bin/git push'
alias ga='/usr/bin/git add'
alias gd='/usr/bin/git diff'
alias gs='/usr/bin/git stash'
alias gb='/usr/bin/git branch'
alias gba='/usr/bin/git branch -a'
alias gc='/usr/bin/git commit'
alias gca='/usr/bin/git commit -a'
alias gco='/usr/bin/git checkout'
alias gm="/usr/bin/git merge --no-ff"
alias gff="/usr/bin/git merge --ff-only"
alias gl="/usr/bin/git log --date-order --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative"
alias gla="/usr/bin/git log --date-order --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative --all"
alias gll="/usr/bin/git log --date-order --graph --oneline"

# Docker
alias d="/usr/bin/sudo /usr/bin/docker"
alias de="/usr/bin/sudo /usr/bin/docker exec"
alias dc="/usr/bin/sudo /usr/bin/docker container"
alias dca="/usr/bin/sudo /usr/bin/docker container attach"
alias dps="/usr/bin/sudo /usr/bin/docker container ls -a --format \"table {{.Names}} \t {{.Image}} \t {{.RunningFor}} \t {{.Status}} \t {{.Ports}}\" "

function dsh () {
    /usr/bin/sudo /usr/bin/docker exec -it $1 /bin/sh
}

# Docker Compose
alias dk="/usr/bin/sudo /usr/bin/docker-compose"
alias dkps="/usr/bin/sudo /usr/bin/docker-compose ps"

alias feh="feh --auto-zoom --borderless --draw-filename --geometry 800x600"

alias src="source ~/.bashrc"

alias C1="awk '{print \$1}'"
alias C2="awk '{print \$2}'"
alias C3="awk '{print \$3}'"
alias C4="awk '{print \$4}'"
alias C5="awk '{print \$5}'"
alias C6="awk '{print \$6}'"
alias C7="awk '{print \$7}'"
alias C8="awk '{print \$8}'"
alias sum="awk '{sum+=\$1} END {print sum}'"

# Custom from Elie

# Python virtualenv
export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
export WORKON_HOME=/home/rothaq/.virtualenvs
source /usr/bin/virtualenvwrapper.sh
alias workoff='deactivate'
alias mkvirtualenv2="mkvirtualenv -p /usr/bin/python2.7"

# Allow StrideSender to be imported
export PYTHONPATH=$PYTHONPATH:~/code/intsys-scripts/stride

# AWS CLI
. ~/code/awscli-saml-auth/bashrc_additions
if [[ -f /home/rothaq/.virtualenvs/awscli/share/cloudtoken/shell_additions/bashrc_additions ]]; then
    source /home/rothaq/.virtualenvs/awscli/share/cloudtoken/shell_additions/bashrc_additions
fi

# GO, Ruby, NodeJS Path
export GOPATH=$HOME/go
export GOBIN=$GOPATH/bin
export PATH=$PATH:$HOME/node_modules/.bin:$HOME/.gem/ruby/2.5.0/bin:$GOBIN
source /usr/share/nvm/init-nvm.sh

# Look at logs of all containers that listen on port 8080
alias docker-logs-check='while ((1)); do sudo docker logs -f $(sudo docker ps | grep 8080 | cut -f1 -d" ") 2>/dev/null; sleep 1; echo No docker container; done'

# Redirect screenshots to ~/shots
alias scrot="scrot ~/shots/%Y-%m-%d-%T-screenshot.png"

# Docker requires sudo access
alias docker="/usr/bin/sudo /usr/bin/docker"
alias docker-compose="/usr/bin/sudo /usr/bin/docker-compose"

# Arch Linux way of handling Java versions
source /etc/profile.d/jre.sh

alias ag="ag --width 200"
alias untar="tar -xvzf"

# Mount and set permissions properly (files: rw- r-- r--, dir: rwxr-xr-x)
alias m="sudo mount -o uid=$USER,fmask=0133,dmask=0022"

# Source additional bashrc config specific to work
source ~/.bashrc_work
